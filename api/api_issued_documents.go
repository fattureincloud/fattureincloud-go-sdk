/*
Fatture in Cloud API v2 - API Reference

Connect your software with Fatture in Cloud, the invoicing platform chosen by more than 500.000 businesses in Italy.   The Fatture in Cloud API is based on REST, and makes possible to interact with the user related data prior authorization via OAuth2 protocol.

API version: 2.0.30
Contact: info@fattureincloud.it
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package api

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"os"
	. "github.com/fattureincloud/fattureincloud-go-sdk/v2/model"
)


// IssuedDocumentsAPIService IssuedDocumentsAPI service
type IssuedDocumentsAPIService service

type ApiCreateIssuedDocumentRequest struct {
	ctx context.Context
	ApiService *IssuedDocumentsAPIService
	companyId int32
	createIssuedDocumentRequest *CreateIssuedDocumentRequest
}

// The Issued Document
func (r ApiCreateIssuedDocumentRequest) CreateIssuedDocumentRequest(createIssuedDocumentRequest CreateIssuedDocumentRequest) ApiCreateIssuedDocumentRequest {
	r.createIssuedDocumentRequest = &createIssuedDocumentRequest
	return r
}

func (r ApiCreateIssuedDocumentRequest) Execute() (*CreateIssuedDocumentResponse, *http.Response, error) {
	return r.ApiService.CreateIssuedDocumentExecute(r)
}

/*
CreateIssuedDocument Create Issued Document

Creates a new document.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param companyId The ID of the company.
 @return ApiCreateIssuedDocumentRequest
*/
func (a *IssuedDocumentsAPIService) CreateIssuedDocument(ctx context.Context, companyId int32) ApiCreateIssuedDocumentRequest {
	return ApiCreateIssuedDocumentRequest{
		ApiService: a,
		ctx: ctx,
		companyId: companyId,
	}
}

// Execute executes the request
//  @return CreateIssuedDocumentResponse
func (a *IssuedDocumentsAPIService) CreateIssuedDocumentExecute(r ApiCreateIssuedDocumentRequest) (*CreateIssuedDocumentResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateIssuedDocumentResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssuedDocumentsAPIService.CreateIssuedDocument")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/c/{company_id}/issued_documents"
	localVarPath = strings.Replace(localVarPath, "{"+"company_id"+"}", url.PathEscape(parameterValueToString(r.companyId, "companyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createIssuedDocumentRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteIssuedDocumentRequest struct {
	ctx context.Context
	ApiService *IssuedDocumentsAPIService
	companyId int32
	documentId int32
}

func (r ApiDeleteIssuedDocumentRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteIssuedDocumentExecute(r)
}

/*
DeleteIssuedDocument Delete Issued Document

Deletes the specified document.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param companyId The ID of the company.
 @param documentId The ID of the document.
 @return ApiDeleteIssuedDocumentRequest
*/
func (a *IssuedDocumentsAPIService) DeleteIssuedDocument(ctx context.Context, companyId int32, documentId int32) ApiDeleteIssuedDocumentRequest {
	return ApiDeleteIssuedDocumentRequest{
		ApiService: a,
		ctx: ctx,
		companyId: companyId,
		documentId: documentId,
	}
}

// Execute executes the request
func (a *IssuedDocumentsAPIService) DeleteIssuedDocumentExecute(r ApiDeleteIssuedDocumentRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssuedDocumentsAPIService.DeleteIssuedDocument")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/c/{company_id}/issued_documents/{document_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"company_id"+"}", url.PathEscape(parameterValueToString(r.companyId, "companyId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"document_id"+"}", url.PathEscape(parameterValueToString(r.documentId, "documentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteIssuedDocumentAttachmentRequest struct {
	ctx context.Context
	ApiService *IssuedDocumentsAPIService
	companyId int32
	documentId int32
}

func (r ApiDeleteIssuedDocumentAttachmentRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteIssuedDocumentAttachmentExecute(r)
}

/*
DeleteIssuedDocumentAttachment Delete Issued Document Attachment

Removes the attachment of the specified document.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param companyId The ID of the company.
 @param documentId The ID of the document.
 @return ApiDeleteIssuedDocumentAttachmentRequest
*/
func (a *IssuedDocumentsAPIService) DeleteIssuedDocumentAttachment(ctx context.Context, companyId int32, documentId int32) ApiDeleteIssuedDocumentAttachmentRequest {
	return ApiDeleteIssuedDocumentAttachmentRequest{
		ApiService: a,
		ctx: ctx,
		companyId: companyId,
		documentId: documentId,
	}
}

// Execute executes the request
func (a *IssuedDocumentsAPIService) DeleteIssuedDocumentAttachmentExecute(r ApiDeleteIssuedDocumentAttachmentRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssuedDocumentsAPIService.DeleteIssuedDocumentAttachment")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/c/{company_id}/issued_documents/{document_id}/attachment"
	localVarPath = strings.Replace(localVarPath, "{"+"company_id"+"}", url.PathEscape(parameterValueToString(r.companyId, "companyId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"document_id"+"}", url.PathEscape(parameterValueToString(r.documentId, "documentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetEmailDataRequest struct {
	ctx context.Context
	ApiService *IssuedDocumentsAPIService
	companyId int32
	documentId int32
}

func (r ApiGetEmailDataRequest) Execute() (*GetEmailDataResponse, *http.Response, error) {
	return r.ApiService.GetEmailDataExecute(r)
}

/*
GetEmailData Get Email Data

Gets the pre-compiled email details.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param companyId The ID of the company.
 @param documentId The ID of the document.
 @return ApiGetEmailDataRequest
*/
func (a *IssuedDocumentsAPIService) GetEmailData(ctx context.Context, companyId int32, documentId int32) ApiGetEmailDataRequest {
	return ApiGetEmailDataRequest{
		ApiService: a,
		ctx: ctx,
		companyId: companyId,
		documentId: documentId,
	}
}

// Execute executes the request
//  @return GetEmailDataResponse
func (a *IssuedDocumentsAPIService) GetEmailDataExecute(r ApiGetEmailDataRequest) (*GetEmailDataResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetEmailDataResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssuedDocumentsAPIService.GetEmailData")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/c/{company_id}/issued_documents/{document_id}/email"
	localVarPath = strings.Replace(localVarPath, "{"+"company_id"+"}", url.PathEscape(parameterValueToString(r.companyId, "companyId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"document_id"+"}", url.PathEscape(parameterValueToString(r.documentId, "documentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetExistingIssuedDocumentTotalsRequest struct {
	ctx context.Context
	ApiService *IssuedDocumentsAPIService
	companyId int32
	documentId int32
	getExistingIssuedDocumentTotalsRequest *GetExistingIssuedDocumentTotalsRequest
}

func (r ApiGetExistingIssuedDocumentTotalsRequest) GetExistingIssuedDocumentTotalsRequest(getExistingIssuedDocumentTotalsRequest GetExistingIssuedDocumentTotalsRequest) ApiGetExistingIssuedDocumentTotalsRequest {
	r.getExistingIssuedDocumentTotalsRequest = &getExistingIssuedDocumentTotalsRequest
	return r
}

func (r ApiGetExistingIssuedDocumentTotalsRequest) Execute() (*GetExistingIssuedDocumentTotalsResponse, *http.Response, error) {
	return r.ApiService.GetExistingIssuedDocumentTotalsExecute(r)
}

/*
GetExistingIssuedDocumentTotals Get Existing Issued Document Totals

Returns the totals for a specified document.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param companyId The ID of the company.
 @param documentId The ID of the document.
 @return ApiGetExistingIssuedDocumentTotalsRequest
*/
func (a *IssuedDocumentsAPIService) GetExistingIssuedDocumentTotals(ctx context.Context, companyId int32, documentId int32) ApiGetExistingIssuedDocumentTotalsRequest {
	return ApiGetExistingIssuedDocumentTotalsRequest{
		ApiService: a,
		ctx: ctx,
		companyId: companyId,
		documentId: documentId,
	}
}

// Execute executes the request
//  @return GetExistingIssuedDocumentTotalsResponse
func (a *IssuedDocumentsAPIService) GetExistingIssuedDocumentTotalsExecute(r ApiGetExistingIssuedDocumentTotalsRequest) (*GetExistingIssuedDocumentTotalsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetExistingIssuedDocumentTotalsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssuedDocumentsAPIService.GetExistingIssuedDocumentTotals")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/c/{company_id}/issued_documents/{document_id}/totals"
	localVarPath = strings.Replace(localVarPath, "{"+"company_id"+"}", url.PathEscape(parameterValueToString(r.companyId, "companyId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"document_id"+"}", url.PathEscape(parameterValueToString(r.documentId, "documentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.getExistingIssuedDocumentTotalsRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetIssuedDocumentRequest struct {
	ctx context.Context
	ApiService *IssuedDocumentsAPIService
	companyId int32
	documentId int32
	fields *string
	fieldset *string
}

// List of comma-separated fields.
func (r ApiGetIssuedDocumentRequest) Fields(fields string) ApiGetIssuedDocumentRequest {
	r.fields = &fields
	return r
}

// Name of the fieldset.
func (r ApiGetIssuedDocumentRequest) Fieldset(fieldset string) ApiGetIssuedDocumentRequest {
	r.fieldset = &fieldset
	return r
}

func (r ApiGetIssuedDocumentRequest) Execute() (*GetIssuedDocumentResponse, *http.Response, error) {
	return r.ApiService.GetIssuedDocumentExecute(r)
}

/*
GetIssuedDocument Get Issued Document

Gets the specified document.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param companyId The ID of the company.
 @param documentId The ID of the document.
 @return ApiGetIssuedDocumentRequest
*/
func (a *IssuedDocumentsAPIService) GetIssuedDocument(ctx context.Context, companyId int32, documentId int32) ApiGetIssuedDocumentRequest {
	return ApiGetIssuedDocumentRequest{
		ApiService: a,
		ctx: ctx,
		companyId: companyId,
		documentId: documentId,
	}
}

// Execute executes the request
//  @return GetIssuedDocumentResponse
func (a *IssuedDocumentsAPIService) GetIssuedDocumentExecute(r ApiGetIssuedDocumentRequest) (*GetIssuedDocumentResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetIssuedDocumentResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssuedDocumentsAPIService.GetIssuedDocument")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/c/{company_id}/issued_documents/{document_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"company_id"+"}", url.PathEscape(parameterValueToString(r.companyId, "companyId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"document_id"+"}", url.PathEscape(parameterValueToString(r.documentId, "documentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	if r.fieldset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fieldset", r.fieldset, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetIssuedDocumentPreCreateInfoRequest struct {
	ctx context.Context
	ApiService *IssuedDocumentsAPIService
	companyId int32
	type_ *string
}

// The type of the issued document.
func (r ApiGetIssuedDocumentPreCreateInfoRequest) Type_(type_ string) ApiGetIssuedDocumentPreCreateInfoRequest {
	r.type_ = &type_
	return r
}

func (r ApiGetIssuedDocumentPreCreateInfoRequest) Execute() (*GetIssuedDocumentPreCreateInfoResponse, *http.Response, error) {
	return r.ApiService.GetIssuedDocumentPreCreateInfoExecute(r)
}

/*
GetIssuedDocumentPreCreateInfo Get Issued Document Pre-Create Info

Retrieves the information useful while creating a new document.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param companyId The ID of the company.
 @return ApiGetIssuedDocumentPreCreateInfoRequest
*/
func (a *IssuedDocumentsAPIService) GetIssuedDocumentPreCreateInfo(ctx context.Context, companyId int32) ApiGetIssuedDocumentPreCreateInfoRequest {
	return ApiGetIssuedDocumentPreCreateInfoRequest{
		ApiService: a,
		ctx: ctx,
		companyId: companyId,
	}
}

// Execute executes the request
//  @return GetIssuedDocumentPreCreateInfoResponse
func (a *IssuedDocumentsAPIService) GetIssuedDocumentPreCreateInfoExecute(r ApiGetIssuedDocumentPreCreateInfoRequest) (*GetIssuedDocumentPreCreateInfoResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetIssuedDocumentPreCreateInfoResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssuedDocumentsAPIService.GetIssuedDocumentPreCreateInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/c/{company_id}/issued_documents/info"
	localVarPath = strings.Replace(localVarPath, "{"+"company_id"+"}", url.PathEscape(parameterValueToString(r.companyId, "companyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.type_ == nil {
		return localVarReturnValue, nil, reportError("type_ is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetNewIssuedDocumentTotalsRequest struct {
	ctx context.Context
	ApiService *IssuedDocumentsAPIService
	companyId int32
	getNewIssuedDocumentTotalsRequest *GetNewIssuedDocumentTotalsRequest
}

func (r ApiGetNewIssuedDocumentTotalsRequest) GetNewIssuedDocumentTotalsRequest(getNewIssuedDocumentTotalsRequest GetNewIssuedDocumentTotalsRequest) ApiGetNewIssuedDocumentTotalsRequest {
	r.getNewIssuedDocumentTotalsRequest = &getNewIssuedDocumentTotalsRequest
	return r
}

func (r ApiGetNewIssuedDocumentTotalsRequest) Execute() (*GetNewIssuedDocumentTotalsResponse, *http.Response, error) {
	return r.ApiService.GetNewIssuedDocumentTotalsExecute(r)
}

/*
GetNewIssuedDocumentTotals Get New Issued Document Totals

Returns the totals for a new document.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param companyId The ID of the company.
 @return ApiGetNewIssuedDocumentTotalsRequest
*/
func (a *IssuedDocumentsAPIService) GetNewIssuedDocumentTotals(ctx context.Context, companyId int32) ApiGetNewIssuedDocumentTotalsRequest {
	return ApiGetNewIssuedDocumentTotalsRequest{
		ApiService: a,
		ctx: ctx,
		companyId: companyId,
	}
}

// Execute executes the request
//  @return GetNewIssuedDocumentTotalsResponse
func (a *IssuedDocumentsAPIService) GetNewIssuedDocumentTotalsExecute(r ApiGetNewIssuedDocumentTotalsRequest) (*GetNewIssuedDocumentTotalsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetNewIssuedDocumentTotalsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssuedDocumentsAPIService.GetNewIssuedDocumentTotals")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/c/{company_id}/issued_documents/totals"
	localVarPath = strings.Replace(localVarPath, "{"+"company_id"+"}", url.PathEscape(parameterValueToString(r.companyId, "companyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.getNewIssuedDocumentTotalsRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiJoinIssuedDocumentsRequest struct {
	ctx context.Context
	ApiService *IssuedDocumentsAPIService
	companyId int32
	ids *string
	group *int32
	eInvoice *int32
}

// Ids of the documents.
func (r ApiJoinIssuedDocumentsRequest) Ids(ids string) ApiJoinIssuedDocumentsRequest {
	r.ids = &ids
	return r
}

// Group items.
func (r ApiJoinIssuedDocumentsRequest) Group(group int32) ApiJoinIssuedDocumentsRequest {
	r.group = &group
	return r
}

// New document e_invoice.
func (r ApiJoinIssuedDocumentsRequest) EInvoice(eInvoice int32) ApiJoinIssuedDocumentsRequest {
	r.eInvoice = &eInvoice
	return r
}

func (r ApiJoinIssuedDocumentsRequest) Execute() (*JoinIssuedDocumentsResponse, *http.Response, error) {
	return r.ApiService.JoinIssuedDocumentsExecute(r)
}

/*
JoinIssuedDocuments Join Issued Documents

Joins issued documents.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param companyId The ID of the company.
 @return ApiJoinIssuedDocumentsRequest
*/
func (a *IssuedDocumentsAPIService) JoinIssuedDocuments(ctx context.Context, companyId int32) ApiJoinIssuedDocumentsRequest {
	return ApiJoinIssuedDocumentsRequest{
		ApiService: a,
		ctx: ctx,
		companyId: companyId,
	}
}

// Execute executes the request
//  @return JoinIssuedDocumentsResponse
func (a *IssuedDocumentsAPIService) JoinIssuedDocumentsExecute(r ApiJoinIssuedDocumentsRequest) (*JoinIssuedDocumentsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *JoinIssuedDocumentsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssuedDocumentsAPIService.JoinIssuedDocuments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/c/{company_id}/issued_documents/join"
	localVarPath = strings.Replace(localVarPath, "{"+"company_id"+"}", url.PathEscape(parameterValueToString(r.companyId, "companyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ids == nil {
		return localVarReturnValue, nil, reportError("ids is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "ids", r.ids, "")
	if r.group != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "group", r.group, "")
	}
	if r.eInvoice != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "e_invoice", r.eInvoice, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListIssuedDocumentsRequest struct {
	ctx context.Context
	ApiService *IssuedDocumentsAPIService
	companyId int32
	type_ *string
	fields *string
	fieldset *string
	sort *string
	page *int32
	perPage *int32
	q *string
	inclusive *int32
}

// The type of the issued document.
func (r ApiListIssuedDocumentsRequest) Type_(type_ string) ApiListIssuedDocumentsRequest {
	r.type_ = &type_
	return r
}

// List of comma-separated fields.
func (r ApiListIssuedDocumentsRequest) Fields(fields string) ApiListIssuedDocumentsRequest {
	r.fields = &fields
	return r
}

// Name of the fieldset.
func (r ApiListIssuedDocumentsRequest) Fieldset(fieldset string) ApiListIssuedDocumentsRequest {
	r.fieldset = &fieldset
	return r
}

// List of comma-separated fields for result sorting (minus for desc sorting).
func (r ApiListIssuedDocumentsRequest) Sort(sort string) ApiListIssuedDocumentsRequest {
	r.sort = &sort
	return r
}

// The page to retrieve.
func (r ApiListIssuedDocumentsRequest) Page(page int32) ApiListIssuedDocumentsRequest {
	r.page = &page
	return r
}

// The size of the page.
func (r ApiListIssuedDocumentsRequest) PerPage(perPage int32) ApiListIssuedDocumentsRequest {
	r.perPage = &perPage
	return r
}

// Query for filtering the results.
func (r ApiListIssuedDocumentsRequest) Q(q string) ApiListIssuedDocumentsRequest {
	r.q = &q
	return r
}

// (Only for type &#x3D; delivery_notes) Include invoices delivery notes.
func (r ApiListIssuedDocumentsRequest) Inclusive(inclusive int32) ApiListIssuedDocumentsRequest {
	r.inclusive = &inclusive
	return r
}

func (r ApiListIssuedDocumentsRequest) Execute() (*ListIssuedDocumentsResponse, *http.Response, error) {
	return r.ApiService.ListIssuedDocumentsExecute(r)
}

/*
ListIssuedDocuments List Issued Documents

Lists the issued documents.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param companyId The ID of the company.
 @return ApiListIssuedDocumentsRequest
*/
func (a *IssuedDocumentsAPIService) ListIssuedDocuments(ctx context.Context, companyId int32) ApiListIssuedDocumentsRequest {
	return ApiListIssuedDocumentsRequest{
		ApiService: a,
		ctx: ctx,
		companyId: companyId,
	}
}

// Execute executes the request
//  @return ListIssuedDocumentsResponse
func (a *IssuedDocumentsAPIService) ListIssuedDocumentsExecute(r ApiListIssuedDocumentsRequest) (*ListIssuedDocumentsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListIssuedDocumentsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssuedDocumentsAPIService.ListIssuedDocuments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/c/{company_id}/issued_documents"
	localVarPath = strings.Replace(localVarPath, "{"+"company_id"+"}", url.PathEscape(parameterValueToString(r.companyId, "companyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.type_ == nil {
		return localVarReturnValue, nil, reportError("type_ is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	if r.fieldset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fieldset", r.fieldset, "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
 		var defaultValue int32 = 1
 		r.page = &defaultValue
 	}
	if r.perPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "per_page", r.perPage, "")
	} else {
 		var defaultValue int32 = 5
 		r.perPage = &defaultValue
 	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "")
	}
	if r.inclusive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inclusive", r.inclusive, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiModifyIssuedDocumentRequest struct {
	ctx context.Context
	ApiService *IssuedDocumentsAPIService
	companyId int32
	documentId int32
	modifyIssuedDocumentRequest *ModifyIssuedDocumentRequest
}

// The modified document
func (r ApiModifyIssuedDocumentRequest) ModifyIssuedDocumentRequest(modifyIssuedDocumentRequest ModifyIssuedDocumentRequest) ApiModifyIssuedDocumentRequest {
	r.modifyIssuedDocumentRequest = &modifyIssuedDocumentRequest
	return r
}

func (r ApiModifyIssuedDocumentRequest) Execute() (*ModifyIssuedDocumentResponse, *http.Response, error) {
	return r.ApiService.ModifyIssuedDocumentExecute(r)
}

/*
ModifyIssuedDocument Modify Issued Document

Modifies the specified document.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param companyId The ID of the company.
 @param documentId The ID of the document.
 @return ApiModifyIssuedDocumentRequest
*/
func (a *IssuedDocumentsAPIService) ModifyIssuedDocument(ctx context.Context, companyId int32, documentId int32) ApiModifyIssuedDocumentRequest {
	return ApiModifyIssuedDocumentRequest{
		ApiService: a,
		ctx: ctx,
		companyId: companyId,
		documentId: documentId,
	}
}

// Execute executes the request
//  @return ModifyIssuedDocumentResponse
func (a *IssuedDocumentsAPIService) ModifyIssuedDocumentExecute(r ApiModifyIssuedDocumentRequest) (*ModifyIssuedDocumentResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModifyIssuedDocumentResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssuedDocumentsAPIService.ModifyIssuedDocument")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/c/{company_id}/issued_documents/{document_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"company_id"+"}", url.PathEscape(parameterValueToString(r.companyId, "companyId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"document_id"+"}", url.PathEscape(parameterValueToString(r.documentId, "documentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.modifyIssuedDocumentRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiScheduleEmailRequest struct {
	ctx context.Context
	ApiService *IssuedDocumentsAPIService
	companyId int32
	documentId int32
	scheduleEmailRequest *ScheduleEmailRequest
}

// Email Schedule
func (r ApiScheduleEmailRequest) ScheduleEmailRequest(scheduleEmailRequest ScheduleEmailRequest) ApiScheduleEmailRequest {
	r.scheduleEmailRequest = &scheduleEmailRequest
	return r
}

func (r ApiScheduleEmailRequest) Execute() (*http.Response, error) {
	return r.ApiService.ScheduleEmailExecute(r)
}

/*
ScheduleEmail Schedule Email

Schedules the sending of a document by email.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param companyId The ID of the company.
 @param documentId The ID of the document.
 @return ApiScheduleEmailRequest
*/
func (a *IssuedDocumentsAPIService) ScheduleEmail(ctx context.Context, companyId int32, documentId int32) ApiScheduleEmailRequest {
	return ApiScheduleEmailRequest{
		ApiService: a,
		ctx: ctx,
		companyId: companyId,
		documentId: documentId,
	}
}

// Execute executes the request
func (a *IssuedDocumentsAPIService) ScheduleEmailExecute(r ApiScheduleEmailRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssuedDocumentsAPIService.ScheduleEmail")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/c/{company_id}/issued_documents/{document_id}/email"
	localVarPath = strings.Replace(localVarPath, "{"+"company_id"+"}", url.PathEscape(parameterValueToString(r.companyId, "companyId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"document_id"+"}", url.PathEscape(parameterValueToString(r.documentId, "documentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.scheduleEmailRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiTransformIssuedDocumentRequest struct {
	ctx context.Context
	ApiService *IssuedDocumentsAPIService
	companyId int32
	originalDocumentId *int32
	newType *string
	eInvoice *int32
	transformKeepCopy *int32
}

// Original document id.
func (r ApiTransformIssuedDocumentRequest) OriginalDocumentId(originalDocumentId int32) ApiTransformIssuedDocumentRequest {
	r.originalDocumentId = &originalDocumentId
	return r
}

// New document type.
func (r ApiTransformIssuedDocumentRequest) NewType(newType string) ApiTransformIssuedDocumentRequest {
	r.newType = &newType
	return r
}

// New document e_invoice.
func (r ApiTransformIssuedDocumentRequest) EInvoice(eInvoice int32) ApiTransformIssuedDocumentRequest {
	r.eInvoice = &eInvoice
	return r
}

// Keep the old document.
func (r ApiTransformIssuedDocumentRequest) TransformKeepCopy(transformKeepCopy int32) ApiTransformIssuedDocumentRequest {
	r.transformKeepCopy = &transformKeepCopy
	return r
}

func (r ApiTransformIssuedDocumentRequest) Execute() (*TransformIssuedDocumentResponse, *http.Response, error) {
	return r.ApiService.TransformIssuedDocumentExecute(r)
}

/*
TransformIssuedDocument Transform Issued Document

Transforms the document.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param companyId The ID of the company.
 @return ApiTransformIssuedDocumentRequest
*/
func (a *IssuedDocumentsAPIService) TransformIssuedDocument(ctx context.Context, companyId int32) ApiTransformIssuedDocumentRequest {
	return ApiTransformIssuedDocumentRequest{
		ApiService: a,
		ctx: ctx,
		companyId: companyId,
	}
}

// Execute executes the request
//  @return TransformIssuedDocumentResponse
func (a *IssuedDocumentsAPIService) TransformIssuedDocumentExecute(r ApiTransformIssuedDocumentRequest) (*TransformIssuedDocumentResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TransformIssuedDocumentResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssuedDocumentsAPIService.TransformIssuedDocument")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/c/{company_id}/issued_documents/transform"
	localVarPath = strings.Replace(localVarPath, "{"+"company_id"+"}", url.PathEscape(parameterValueToString(r.companyId, "companyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.originalDocumentId == nil {
		return localVarReturnValue, nil, reportError("originalDocumentId is required and must be specified")
	}
	if r.newType == nil {
		return localVarReturnValue, nil, reportError("newType is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "original_document_id", r.originalDocumentId, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "new_type", r.newType, "")
	if r.eInvoice != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "e_invoice", r.eInvoice, "")
	}
	if r.transformKeepCopy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transform_keep_copy", r.transformKeepCopy, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUploadIssuedDocumentAttachmentRequest struct {
	ctx context.Context
	ApiService *IssuedDocumentsAPIService
	companyId int32
	filename *string
	attachment *os.File
}

// Attachment file name
func (r ApiUploadIssuedDocumentAttachmentRequest) Filename(filename string) ApiUploadIssuedDocumentAttachmentRequest {
	r.filename = &filename
	return r
}

// Attachment file [.png, .jpg, .gif, .pdf, .zip, .xls, .xlsx, .doc, .docx]
func (r ApiUploadIssuedDocumentAttachmentRequest) Attachment(attachment *os.File) ApiUploadIssuedDocumentAttachmentRequest {
	r.attachment = attachment
	return r
}

func (r ApiUploadIssuedDocumentAttachmentRequest) Execute() (*UploadIssuedDocumentAttachmentResponse, *http.Response, error) {
	return r.ApiService.UploadIssuedDocumentAttachmentExecute(r)
}

/*
UploadIssuedDocumentAttachment Upload Issued Document Attachment

Uploads an attachment destined to an issued document. The actual association between the document and the attachment must be implemented separately, using the returned token.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param companyId The ID of the company.
 @return ApiUploadIssuedDocumentAttachmentRequest
*/
func (a *IssuedDocumentsAPIService) UploadIssuedDocumentAttachment(ctx context.Context, companyId int32) ApiUploadIssuedDocumentAttachmentRequest {
	return ApiUploadIssuedDocumentAttachmentRequest{
		ApiService: a,
		ctx: ctx,
		companyId: companyId,
	}
}

// Execute executes the request
//  @return UploadIssuedDocumentAttachmentResponse
func (a *IssuedDocumentsAPIService) UploadIssuedDocumentAttachmentExecute(r ApiUploadIssuedDocumentAttachmentRequest) (*UploadIssuedDocumentAttachmentResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UploadIssuedDocumentAttachmentResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssuedDocumentsAPIService.UploadIssuedDocumentAttachment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/c/{company_id}/issued_documents/attachment"
	localVarPath = strings.Replace(localVarPath, "{"+"company_id"+"}", url.PathEscape(parameterValueToString(r.companyId, "companyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.filename != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "filename", r.filename, "")
	}
	var attachmentLocalVarFormFileName string
	var attachmentLocalVarFileName     string
	var attachmentLocalVarFileBytes    []byte

	attachmentLocalVarFormFileName = "attachment"


	attachmentLocalVarFile := r.attachment

	if attachmentLocalVarFile != nil {
		fbs, _ := io.ReadAll(attachmentLocalVarFile)

		attachmentLocalVarFileBytes = fbs
		attachmentLocalVarFileName = attachmentLocalVarFile.Name()
		attachmentLocalVarFile.Close()
		formFiles = append(formFiles, formFile{fileBytes: attachmentLocalVarFileBytes, fileName: attachmentLocalVarFileName, formFileName: attachmentLocalVarFormFileName})
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
